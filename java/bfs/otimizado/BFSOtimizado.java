/**
 * Implementa√ß√£o Otimizada do Algoritmo BFS (Busca em Largura)
 * ===========================================================
 * 
 * Esta implementa√ß√£o inclui v√°rias otimiza√ß√µes:
 * - Uso de ArrayDeque para melhor performance
 * - Verifica√ß√£o de visitados mais eficiente
 * - Suporte a diferentes tipos de dados gen√©ricos
 * - Estat√≠sticas de performance
 * - Parada antecipada quando destino √© encontrado
 * 
 * Caracter√≠sticas desta vers√£o:
 * - Complexidade: O(V + E) onde V = v√©rtices, E = arestas
 * - Uso de estruturas de dados otimizadas
 * - Interface mais flex√≠vel e robusta
 * - Coleta de m√©tricas de performance
 * 
 * @author matheussricardoo
 * @version 2.0
 * @since Julho 2025
 */

package bfs.otimizado;

import java.util.*;

/**
 * Classe que armazena estat√≠sticas de performance do BFS
 */
class EstatisticasPerformance {
    private long totalOperacoes;
    private long tempoTotalExecucao;
    private int totalVerticesVisitados;
    private int totalArestasExploradas;
    private long tempoUltimaOperacao;
    
    public EstatisticasPerformance() {
        this.totalOperacoes = 0;
        this.tempoTotalExecucao = 0;
        this.totalVerticesVisitados = 0;
        this.totalArestasExploradas = 0;
    }
    
    public void registrarOperacao(long tempoExecucao, int verticesVisitados, int arestasExploradas) {
        this.totalOperacoes++;
        this.tempoTotalExecucao += tempoExecucao;
        this.totalVerticesVisitados += verticesVisitados;
        this.totalArestasExploradas += arestasExploradas;
        this.tempoUltimaOperacao = tempoExecucao;
    }
    
    public void imprimir() {
        System.out.println("\nüìä ESTAT√çSTICAS DE PERFORMANCE");
        System.out.println("=".repeat(40));
        System.out.println("üìà Total de opera√ß√µes BFS: " + totalOperacoes);
        System.out.println("‚è±Ô∏è  Tempo total de execu√ß√£o: " + (tempoTotalExecucao / 1_000_000.0) + " ms");
        System.out.println("üîç V√©rtices visitados: " + totalVerticesVisitados);
        System.out.println("üîó Arestas exploradas: " + totalArestasExploradas);
        if (totalOperacoes > 0) {
            System.out.println("‚ö° Tempo m√©dio por opera√ß√£o: " + 
                             (tempoTotalExecucao / totalOperacoes / 1_000_000.0) + " ms");
        }
        System.out.println("‚è∞ √öltima opera√ß√£o: " + (tempoUltimaOperacao / 1_000_000.0) + " ms");
    }
}

/**
 * Classe que armazena o resultado de uma opera√ß√£o BFS
 */
class ResultadoBFS<T> {
    private final T verticeOrigem;
    private final T verticeDestino;
    private final List<T> caminho;
    private final Map<T, Integer> distancias;
    private final boolean encontrado;
    private final long tempoExecucao;
    private final int verticesVisitados;
    private final int arestasExploradas;
    
    public ResultadoBFS(T origem, T destino, List<T> caminho, Map<T, Integer> distancias, 
                       boolean encontrado, long tempoExecucao, int verticesVisitados, int arestasExploradas) {
        this.verticeOrigem = origem;
        this.verticeDestino = destino;
        this.caminho = caminho != null ? new ArrayList<>(caminho) : null;
        this.distancias = distancias != null ? new HashMap<>(distancias) : null;
        this.encontrado = encontrado;
        this.tempoExecucao = tempoExecucao;
        this.verticesVisitados = verticesVisitados;
        this.arestasExploradas = arestasExploradas;
    }
    
    public void imprimirResumo() {
        System.out.println("üéØ Origem: " + verticeOrigem);
        if (verticeDestino != null) {
            System.out.println("üèÅ Destino: " + verticeDestino);
            System.out.println("‚úÖ Encontrado: " + (encontrado ? "Sim" : "N√£o"));
        }
        
        if (caminho != null && !caminho.isEmpty()) {
            System.out.println("üõ£Ô∏è  Caminho encontrado: " + caminho);
            System.out.println("üìè Dist√¢ncia: " + (caminho.size() - 1) + " saltos");
        }
        
        if (distancias != null && !distancias.isEmpty()) {
            System.out.println("üìä Dist√¢ncias calculadas: " + distancias.size() + " v√©rtices");
        }
        
        System.out.println("‚è±Ô∏è  Tempo de execu√ß√£o: " + (tempoExecucao / 1_000_000.0) + " ms");
        System.out.println("üîç V√©rtices visitados: " + verticesVisitados);
        System.out.println("üîó Arestas exploradas: " + arestasExploradas);
    }
    
    public List<T> getCaminho() { return caminho; }
    public Map<T, Integer> getDistancias() { return distancias; }
    public boolean isEncontrado() { return encontrado; }
    public long getTempoExecucao() { return tempoExecucao; }
}

/**
 * Implementa√ß√£o otimizada de um grafo para BFS
 */
class GrafoBFSOtimizado<T> {
    private final Map<T, Set<T>> listaAdjacencia;
    private final EstatisticasPerformance estatisticas;
    
    public GrafoBFSOtimizado() {
        this.listaAdjacencia = new HashMap<>();
        this.estatisticas = new EstatisticasPerformance();
    }
    
    public void adicionarVertice(T vertice) {
        listaAdjacencia.putIfAbsent(vertice, new HashSet<>());
        System.out.println("  ‚úÖ V√©rtice adicionado: " + vertice);
    }
    
    public void adicionarAresta(T origem, T destino) {
        listaAdjacencia.putIfAbsent(origem, new HashSet<>());
        listaAdjacencia.putIfAbsent(destino, new HashSet<>());
        
        listaAdjacencia.get(origem).add(destino);
        listaAdjacencia.get(destino).add(origem);
        
        System.out.println("  üîó Aresta adicionada: " + origem + " ‚Üî " + destino);
    }
    
    public void imprimirGrafo() {
        System.out.println("\nüó∫Ô∏è  Estrutura do Grafo:");
        System.out.println("=" + "=".repeat(30));
        
        for (Map.Entry<T, Set<T>> entry : listaAdjacencia.entrySet()) {
            System.out.println("üìç " + entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
    
    public void imprimirEstatisticasGrafo() {
        int vertices = listaAdjacencia.size();
        int arestas = listaAdjacencia.values().stream()
                                   .mapToInt(Set::size)
                                   .sum() / 2;
        
        System.out.println("\nüìà Estat√≠sticas do Grafo:");
        System.out.println("  üîµ V√©rtices: " + vertices);
        System.out.println("  üîó Arestas: " + arestas);
        System.out.println("  üìä Densidade: " + String.format("%.2f%%", 
                         (2.0 * arestas / (vertices * (vertices - 1))) * 100));
    }
    
    public ResultadoBFS<T> bfsCompleto(T origem) {
        long inicioTempo = System.nanoTime();
        
        if (!listaAdjacencia.containsKey(origem)) {
            return new ResultadoBFS<>(origem, null, null, null, false, 0, 0, 0);
        }
        
        ArrayDeque<T> fila = new ArrayDeque<>();
        Set<T> visitados = new HashSet<>();
        Map<T, Integer> distancias = new HashMap<>();
        Map<T, T> predecessores = new HashMap<>();
        
        fila.offer(origem);
        visitados.add(origem);
        distancias.put(origem, 0);
        
        int verticesVisitados = 0;
        int arestasExploradas = 0;
        
        while (!fila.isEmpty()) {
            T atual = fila.poll();
            verticesVisitados++;
            
            for (T vizinho : listaAdjacencia.get(atual)) {
                arestasExploradas++;
                
                if (!visitados.contains(vizinho)) {
                    visitados.add(vizinho);
                    distancias.put(vizinho, distancias.get(atual) + 1);
                    predecessores.put(vizinho, atual);
                    fila.offer(vizinho);
                }
            }
        }
        
        long tempoExecucao = System.nanoTime() - inicioTempo;
        estatisticas.registrarOperacao(tempoExecucao, verticesVisitados, arestasExploradas);
        
        return new ResultadoBFS<>(origem, null, null, distancias, true, 
                                 tempoExecucao, verticesVisitados, arestasExploradas);
    }
    
    public ResultadoBFS<T> bfsOtimizado(T origem, T destino) {
        long inicioTempo = System.nanoTime();
        
        if (!listaAdjacencia.containsKey(origem) || !listaAdjacencia.containsKey(destino)) {
            return new ResultadoBFS<>(origem, destino, null, null, false, 0, 0, 0);
        }
        
        if (origem.equals(destino)) {
            List<T> caminho = Arrays.asList(origem);
            return new ResultadoBFS<>(origem, destino, caminho, null, true, 
                                     System.nanoTime() - inicioTempo, 1, 0);
        }
        
        ArrayDeque<T> fila = new ArrayDeque<>();
        Set<T> visitados = new HashSet<>();
        Map<T, T> predecessores = new HashMap<>();
        
        fila.offer(origem);
        visitados.add(origem);
        
        int verticesVisitados = 0;
        int arestasExploradas = 0;
        boolean encontrado = false;
        
        while (!fila.isEmpty() && !encontrado) {
            T atual = fila.poll();
            verticesVisitados++;
            
            for (T vizinho : listaAdjacencia.get(atual)) {
                arestasExploradas++;
                
                if (!visitados.contains(vizinho)) {
                    visitados.add(vizinho);
                    predecessores.put(vizinho, atual);
                    fila.offer(vizinho);
                    
                    if (vizinho.equals(destino)) {
                        encontrado = true;
                        break;
                    }
                }
            }
        }
        
        List<T> caminho = null;
        if (encontrado) {
            caminho = new ArrayList<>();
            T atual = destino;
            while (atual != null) {
                caminho.add(0, atual);
                atual = predecessores.get(atual);
            }
        }
        
        long tempoExecucao = System.nanoTime() - inicioTempo;
        estatisticas.registrarOperacao(tempoExecucao, verticesVisitados, arestasExploradas);
        
        return new ResultadoBFS<>(origem, destino, caminho, null, encontrado, 
                                 tempoExecucao, verticesVisitados, arestasExploradas);
    }
    
    public Map<T, Integer> calcularDistancias(T origem) {
        ResultadoBFS<T> resultado = bfsCompleto(origem);
        return resultado.getDistancias();
    }
    
    public Set<T> verticesNoNivel(T origem, int nivel) {
        Map<T, Integer> distancias = calcularDistancias(origem);
        Set<T> resultado = new HashSet<>();
        
        for (Map.Entry<T, Integer> entry : distancias.entrySet()) {
            if (entry.getValue() == nivel) {
                resultado.add(entry.getKey());
            }
        }
        
        return resultado;
    }
    
    public boolean existeCaminho(T origem, T destino) {
        ResultadoBFS<T> resultado = bfsOtimizado(origem, destino);
        return resultado.isEncontrado();
    }
    
    public EstatisticasPerformance obterEstatisticas() {
        return estatisticas;
    }
}

/**
 * Classe principal para demonstra√ß√£o do BFS Otimizado
 */
public class BFSOtimizado {
    
    public static void main(String[] args) {
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë      BFS Otimizado - Demonstra√ß√£o     ‚ïë");
        System.out.println("‚ïë     Implementa√ß√£o Educacional          ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        System.out.println();
        
        // Cria um grafo otimizado de exemplo
        GrafoBFSOtimizado<String> grafo = new GrafoBFSOtimizado<>();
        
        // Adiciona v√©rtices (cidades)
        System.out.println("üèôÔ∏è  Construindo grafo de cidades:");
        grafo.adicionarVertice("S√£o Paulo");
        grafo.adicionarVertice("Rio de Janeiro");
        grafo.adicionarVertice("Belo Horizonte");
        grafo.adicionarVertice("Salvador");
        grafo.adicionarVertice("Bras√≠lia");
        grafo.adicionarVertice("Curitiba");
        
        // Adiciona conex√µes (estradas)
        System.out.println("\nüõ£Ô∏è  Adicionando conex√µes:");
        grafo.adicionarAresta("S√£o Paulo", "Rio de Janeiro");
        grafo.adicionarAresta("S√£o Paulo", "Belo Horizonte");
        grafo.adicionarAresta("S√£o Paulo", "Curitiba");
        grafo.adicionarAresta("Rio de Janeiro", "Belo Horizonte");
        grafo.adicionarAresta("Belo Horizonte", "Salvador");
        grafo.adicionarAresta("Belo Horizonte", "Bras√≠lia");
        grafo.adicionarAresta("Salvador", "Bras√≠lia");
        
        // Mostra informa√ß√µes do grafo
        grafo.imprimirEstatisticasGrafo();
        grafo.imprimirGrafo();
        
        // Exemplo 1: BFS completo
        System.out.println("\n" + "=".repeat(50));
        System.out.println("1Ô∏è‚É£  BFS COMPLETO - Explorando todas as conex√µes");
        System.out.println("=".repeat(50));
        
        ResultadoBFS<String> resultadoCompleto = grafo.bfsCompleto("S√£o Paulo");
        resultadoCompleto.imprimirResumo();
        
        // Exemplo 2: BFS com destino espec√≠fico
        System.out.println("\n" + "=".repeat(50));
        System.out.println("2Ô∏è‚É£  BFS COM DESTINO - Caminho mais curto");
        System.out.println("=".repeat(50));
        
        ResultadoBFS<String> resultadoDestino = grafo.bfsOtimizado("S√£o Paulo", "Salvador");
        resultadoDestino.imprimirResumo();
        
        // Exemplo 3: An√°lise de dist√¢ncias
        System.out.println("\n" + "=".repeat(50));
        System.out.println("3Ô∏è‚É£  AN√ÅLISE DE DIST√ÇNCIAS");
        System.out.println("=".repeat(50));
        
        Map<String, Integer> distancias = grafo.calcularDistancias("S√£o Paulo");
        System.out.println("Dist√¢ncias a partir de S√£o Paulo:");
        distancias.entrySet().stream()
                .sorted(Map.Entry.comparingByValue())
                .forEach(entry -> 
                    System.out.println("  üìç " + entry.getKey() + ": " + entry.getValue() + " saltos"));
        
        // Exemplo 4: V√©rtices por n√≠vel
        System.out.println("\n" + "=".repeat(50));
        System.out.println("4Ô∏è‚É£  V√âRTICES POR N√çVEL");
        System.out.println("=".repeat(50));
        
        for (int nivel = 0; nivel <= 3; nivel++) {
            Set<String> verticesNivel = grafo.verticesNoNivel("S√£o Paulo", nivel);
            if (!verticesNivel.isEmpty()) {
                System.out.println("N√≠vel " + nivel + ": " + verticesNivel);
            }
        }
        
        // Exemplo 5: Verifica√ß√£o de conectividade
        System.out.println("\n" + "=".repeat(50));
        System.out.println("5Ô∏è‚É£  VERIFICA√á√ÉO DE CONECTIVIDADE");
        System.out.println("=".repeat(50));
        
        String[][] pares = {
            {"S√£o Paulo", "Salvador"},
            {"Rio de Janeiro", "Curitiba"},
            {"Bras√≠lia", "S√£o Paulo"},
            {"Curitiba", "Salvador"}
        };
        
        for (String[] par : pares) {
            boolean conectado = grafo.existeCaminho(par[0], par[1]);
            System.out.println("üîó " + par[0] + " ‚Üí " + par[1] + ": " + 
                             (conectado ? "‚úÖ Conectado" : "‚ùå N√£o conectado"));
        }
        
        // Estat√≠sticas finais
        EstatisticasPerformance stats = grafo.obterEstatisticas();
        stats.imprimir();
        
        System.out.println("\nüí° Caracter√≠sticas desta implementa√ß√£o:");
        System.out.println("   ‚Ä¢ Uso de ArrayDeque para melhor performance");
        System.out.println("   ‚Ä¢ Suporte a tipos gen√©ricos");
        System.out.println("   ‚Ä¢ Parada antecipada quando destino √© encontrado");
        System.out.println("   ‚Ä¢ Coleta de m√©tricas de performance");
        System.out.println("   ‚Ä¢ Interface flex√≠vel e robusta");
    }
}
