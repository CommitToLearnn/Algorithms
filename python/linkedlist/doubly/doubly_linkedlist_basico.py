"""
Implementa√ß√£o B√°sica de Lista Duplamente Ligada em Python
=========================================================

Esta implementa√ß√£o demonstra os conceitos fundamentais de uma lista duplamente ligada,
onde cada n√≥ possui ponteiros para o pr√≥ximo E para o anterior elemento.

Caracter√≠sticas desta vers√£o:
- Implementa√ß√£o did√°tica e comentada
- Opera√ß√µes fundamentais claramente explicadas
- Navega√ß√£o bidirecional (frente e tr√°s)
- Inser√ß√µes e remo√ß√µes eficientes em ambas as extremidades
- C√≥digo otimizado para aprendizado

Vantagens da Lista Duplamente Ligada:
- Navega√ß√£o em ambas as dire√ß√µes
- Remo√ß√£o eficiente O(1) quando se tem a refer√™ncia do n√≥
- Inser√ß√£o eficiente em qualquer posi√ß√£o conhecida
- Implementa√ß√£o mais f√°cil de opera√ß√µes como revers√£o

@author matheussricardoo
@version 1.0
@since Julho 2025
"""

from typing import Any, Optional, Iterator


class NoDuplo:
    """
    Classe que representa um n√≥ de uma lista duplamente ligada.
    
    Cada n√≥ cont√©m:
    - dados: o valor armazenado
    - proximo: refer√™ncia para o pr√≥ximo n√≥
    - anterior: refer√™ncia para o n√≥ anterior
    """
    
    def __init__(self, dados: Any, proximo: Optional['NoDuplo'] = None, 
                 anterior: Optional['NoDuplo'] = None):
        """
        Inicializa um n√≥ da lista duplamente ligada.
        
        Args:
            dados: Valor a ser armazenado no n√≥
            proximo: Refer√™ncia para o pr√≥ximo n√≥ (opcional)
            anterior: Refer√™ncia para o n√≥ anterior (opcional)
        """
        self.dados = dados
        self.proximo = proximo
        self.anterior = anterior
    
    def __str__(self) -> str:
        """Representa√ß√£o em string do n√≥."""
        return f"NoDuplo({self.dados})"
    
    def __repr__(self) -> str:
        """Representa√ß√£o detalhada do n√≥."""
        return f"NoDuplo(dados={self.dados}, anterior={self.anterior.dados if self.anterior else None}, proximo={self.proximo.dados if self.proximo else None})"


class ListaDuplamenteLigada:
    """
    Implementa√ß√£o b√°sica de uma Lista Duplamente Ligada.
    
    Esta estrutura permite navega√ß√£o eficiente em ambas as dire√ß√µes
    e opera√ß√µes O(1) nas extremidades.
    """
    
    def __init__(self):
        """
        Inicializa uma lista duplamente ligada vazia.
        
        A lista mant√©m refer√™ncias para:
        - cabeca: primeiro n√≥ da lista
        - cauda: √∫ltimo n√≥ da lista
        - tamanho: n√∫mero de elementos
        """
        self.cabeca = None
        self.cauda = None
        self.tamanho = 0
    
    def esta_vazia(self) -> bool:
        """
        Verifica se a lista est√° vazia.
        
        Returns:
            bool: True se a lista estiver vazia, False caso contr√°rio
        """
        return self.cabeca is None
    
    def obter_tamanho(self) -> int:
        """
        Retorna o n√∫mero de elementos na lista.
        
        Returns:
            int: Tamanho da lista
        """
        return self.tamanho
    
    def inserir_inicio(self, dados: Any) -> None:
        """
        Insere um elemento no in√≠cio da lista. Complexidade: O(1)
        
        Args:
            dados: Valor a ser inserido
        """
        print(f"üîπ Inserindo '{dados}' no in√≠cio da lista")
        
        # Cria o novo n√≥
        novo_no = NoDuplo(dados)
        
        if self.esta_vazia():
            # Lista vazia: novo n√≥ √© tanto cabeca quanto cauda
            self.cabeca = self.cauda = novo_no
            print(f"  ‚úÖ Lista estava vazia. '{dados}' √© agora cabeca e cauda")
        else:
            # Lista n√£o-vazia: ajusta os ponteiros
            novo_no.proximo = self.cabeca
            self.cabeca.anterior = novo_no
            self.cabeca = novo_no
            print(f"  ‚úÖ '{dados}' inserido no in√≠cio. Nova cabeca definida")
        
        self.tamanho += 1
        print(f"  üìä Tamanho atual: {self.tamanho}")
    
    def inserir_fim(self, dados: Any) -> None:
        """
        Insere um elemento no final da lista. Complexidade: O(1)
        
        Args:
            dados: Valor a ser inserido
        """
        print(f"üî∏ Inserindo '{dados}' no final da lista")
        
        # Cria o novo n√≥
        novo_no = NoDuplo(dados)
        
        if self.esta_vazia():
            # Lista vazia: novo n√≥ √© tanto cabeca quanto cauda
            self.cabeca = self.cauda = novo_no
            print(f"  ‚úÖ Lista estava vazia. '{dados}' √© agora cabeca e cauda")
        else:
            # Lista n√£o-vazia: ajusta os ponteiros
            novo_no.anterior = self.cauda
            self.cauda.proximo = novo_no
            self.cauda = novo_no
            print(f"  ‚úÖ '{dados}' inserido no final. Nova cauda definida")
        
        self.tamanho += 1
        print(f"  üìä Tamanho atual: {self.tamanho}")
    
    def inserir_posicao(self, indice: int, dados: Any) -> None:
        """
        Insere um elemento em uma posi√ß√£o espec√≠fica.
        
        Args:
            indice: Posi√ß√£o onde inserir (0-based)
            dados: Valor a ser inserido
            
        Raises:
            IndexError: Se o √≠ndice estiver fora dos limites
        """
        if indice < 0 or indice > self.tamanho:
            raise IndexError(f"√çndice {indice} fora dos limites [0, {self.tamanho}]")
        
        print(f"üî∑ Inserindo '{dados}' na posi√ß√£o {indice}")
        
        # Casos especiais
        if indice == 0:
            self.inserir_inicio(dados)
            return
        elif indice == self.tamanho:
            self.inserir_fim(dados)
            return
        
        # Inser√ß√£o no meio: busca otimizada
        if indice <= self.tamanho // 2:
            # Busca a partir do in√≠cio
            print("  üîç Buscando a partir do in√≠cio (mais pr√≥ximo)")
            no_atual = self.cabeca
            for _ in range(indice):
                no_atual = no_atual.proximo
        else:
            # Busca a partir do final
            print("  üîç Buscando a partir do final (mais pr√≥ximo)")
            no_atual = self.cauda
            for _ in range(self.tamanho - 1, indice, -1):
                no_atual = no_atual.anterior
        
        # Cria e insere o novo n√≥
        novo_no = NoDuplo(dados, no_atual, no_atual.anterior)
        no_atual.anterior.proximo = novo_no
        no_atual.anterior = novo_no
        
        self.tamanho += 1
        print(f"  ‚úÖ '{dados}' inserido na posi√ß√£o {indice}")
        print(f"  üìä Tamanho atual: {self.tamanho}")
    
    def remover_inicio(self) -> Any:
        """
        Remove e retorna o primeiro elemento da lista. Complexidade: O(1)
        
        Returns:
            Any: Dados do elemento removido
            
        Raises:
            IndexError: Se a lista estiver vazia
        """
        if self.esta_vazia():
            raise IndexError("N√£o √© poss√≠vel remover de uma lista vazia")
        
        dados = self.cabeca.dados
        print(f"üóëÔ∏è  Removendo '{dados}' do in√≠cio da lista")
        
        if self.tamanho == 1:
            # √önico elemento: lista fica vazia
            self.cabeca = self.cauda = None
            print("  ‚úÖ Lista ficou vazia ap√≥s remo√ß√£o")
        else:
            # M√∫ltiplos elementos: ajusta ponteiros
            self.cabeca = self.cabeca.proximo
            self.cabeca.anterior = None
            print(f"  ‚úÖ Nova cabeca: '{self.cabeca.dados}'")
        
        self.tamanho -= 1
        print(f"  üìä Tamanho atual: {self.tamanho}")
        
        return dados
    
    def remover_fim(self) -> Any:
        """
        Remove e retorna o √∫ltimo elemento da lista. Complexidade: O(1)
        
        Returns:
            Any: Dados do elemento removido
            
        Raises:
            IndexError: Se a lista estiver vazia
        """
        if self.esta_vazia():
            raise IndexError("N√£o √© poss√≠vel remover de uma lista vazia")
        
        dados = self.cauda.dados
        print(f"üóëÔ∏è  Removendo '{dados}' do final da lista")
        
        if self.tamanho == 1:
            # √önico elemento: lista fica vazia
            self.cabeca = self.cauda = None
            print("  ‚úÖ Lista ficou vazia ap√≥s remo√ß√£o")
        else:
            # M√∫ltiplos elementos: ajusta ponteiros
            self.cauda = self.cauda.anterior
            self.cauda.proximo = None
            print(f"  ‚úÖ Nova cauda: '{self.cauda.dados}'")
        
        self.tamanho -= 1
        print(f"  üìä Tamanho atual: {self.tamanho}")
        
        return dados
    
    def remover_valor(self, dados: Any) -> bool:
        """
        Remove a primeira ocorr√™ncia de um valor espec√≠fico.
        
        Args:
            dados: Valor a ser removido
            
        Returns:
            bool: True se o elemento foi removido, False se n√£o encontrado
        """
        print(f"üîç Procurando '{dados}' para remo√ß√£o")
        
        no_atual = self.cabeca
        
        while no_atual is not None:
            if no_atual.dados == dados:
                print(f"  ‚úÖ Elemento '{dados}' encontrado")
                
                # Ajusta ponteiros do n√≥ anterior
                if no_atual.anterior is not None:
                    no_atual.anterior.proximo = no_atual.proximo
                else:
                    # √â o primeiro n√≥
                    self.cabeca = no_atual.proximo
                
                # Ajusta ponteiros do n√≥ posterior
                if no_atual.proximo is not None:
                    no_atual.proximo.anterior = no_atual.anterior
                else:
                    # √â o √∫ltimo n√≥
                    self.cauda = no_atual.anterior
                
                self.tamanho -= 1
                print(f"  üóëÔ∏è  '{dados}' removido com sucesso")
                print(f"  üìä Tamanho atual: {self.tamanho}")
                return True
            
            no_atual = no_atual.proximo
        
        print(f"  ‚ùå Elemento '{dados}' n√£o encontrado")
        return False
    
    def buscar(self, dados: Any) -> Optional[int]:
        """
        Busca um elemento na lista e retorna seu √≠ndice.
        
        Args:
            dados: Valor a ser buscado
            
        Returns:
            Optional[int]: √çndice do elemento ou None se n√£o encontrado
        """
        print(f"üîç Buscando '{dados}' na lista")
        
        no_atual = self.cabeca
        indice = 0
        
        while no_atual is not None:
            if no_atual.dados == dados:
                print(f"  ‚úÖ '{dados}' encontrado na posi√ß√£o {indice}")
                return indice
            
            no_atual = no_atual.proximo
            indice += 1
        
        print(f"  ‚ùå '{dados}' n√£o encontrado na lista")
        return None
    
    def obter(self, indice: int) -> Any:
        """
        Obt√©m o elemento de uma posi√ß√£o espec√≠fica.
        
        Args:
            indice: Posi√ß√£o do elemento (0-based)
            
        Returns:
            Any: Dados do elemento
            
        Raises:
            IndexError: Se o √≠ndice estiver fora dos limites
        """
        if indice < 0 or indice >= self.tamanho:
            raise IndexError(f"√çndice {indice} fora dos limites [0, {self.tamanho-1}]")
        
        print(f"üîç Obtendo elemento da posi√ß√£o {indice}")
        
        # Busca otimizada: escolhe a dire√ß√£o mais pr√≥xima
        if indice <= self.tamanho // 2:
            # Busca a partir do in√≠cio
            print("  ‚û°Ô∏è  Buscando a partir do in√≠cio")
            no_atual = self.cabeca
            for _ in range(indice):
                no_atual = no_atual.proximo
        else:
            # Busca a partir do final
            print("  ‚¨ÖÔ∏è  Buscando a partir do final")
            no_atual = self.cauda
            for _ in range(self.tamanho - 1, indice, -1):
                no_atual = no_atual.anterior
        
        print(f"  ‚úÖ Elemento encontrado: '{no_atual.dados}'")
        return no_atual.dados
    
    def reverter(self) -> None:
        """
        Reverte a ordem dos elementos na lista. Complexidade: O(n)
        """
        if self.tamanho <= 1:
            print("üìã Lista vazia ou com um elemento - n√£o h√° o que reverter")
            return
        
        print("üîÑ Revertendo a lista...")
        
        no_atual = self.cabeca
        
        # Troca as refer√™ncias anterior/proximo de cada n√≥
        while no_atual is not None:
            # Troca anterior e proximo
            no_atual.anterior, no_atual.proximo = no_atual.proximo, no_atual.anterior
            # Move para o "pr√≥ximo" (que era o anterior)
            no_atual = no_atual.anterior
        
        # Troca cabeca e cauda
        self.cabeca, self.cauda = self.cauda, self.cabeca
        
        print("  ‚úÖ Lista revertida com sucesso")
    
    def para_lista_frente(self) -> list:
        """
        Converte a lista duplamente ligada para uma lista Python (do in√≠cio ao fim).
        
        Returns:
            list: Lista Python com os elementos
        """
        resultado = []
        no_atual = self.cabeca
        
        while no_atual is not None:
            resultado.append(no_atual.dados)
            no_atual = no_atual.proximo
        
        return resultado
    
    def para_lista_tras(self) -> list:
        """
        Converte a lista duplamente ligada para uma lista Python (do fim ao in√≠cio).
        
        Returns:
            list: Lista Python com os elementos em ordem reversa
        """
        resultado = []
        no_atual = self.cauda
        
        while no_atual is not None:
            resultado.append(no_atual.dados)
            no_atual = no_atual.anterior
        
        return resultado
    
    def limpar(self) -> None:
        """
        Remove todos os elementos da lista.
        """
        print("üßπ Limpando a lista...")
        self.cabeca = None
        self.cauda = None
        self.tamanho = 0
        print("  ‚úÖ Lista limpa com sucesso")
    
    def __len__(self) -> int:
        """Suporte ao operador len()."""
        return self.tamanho
    
    def __iter__(self) -> Iterator[Any]:
        """Suporte √† itera√ß√£o Python (do in√≠cio ao fim)."""
        no_atual = self.cabeca
        while no_atual is not None:
            yield no_atual.dados
            no_atual = no_atual.proximo
    
    def iter_reverso(self) -> Iterator[Any]:
        """Iterador que percorre a lista do fim ao in√≠cio."""
        no_atual = self.cauda
        while no_atual is not None:
            yield no_atual.dados
            no_atual = no_atual.anterior
    
    def __str__(self) -> str:
        """Representa√ß√£o em string da lista."""
        if self.esta_vazia():
            return "Lista Duplamente Ligada: vazia"
        
        elementos = " <-> ".join(str(dados) for dados in self)
        return f"Lista Duplamente Ligada: {elementos}"
    
    def __repr__(self) -> str:
        """Representa√ß√£o detalhada da lista."""
        return f"ListaDuplamenteLigada({self.para_lista_frente()})"
    
    def imprimir_detalhado(self) -> None:
        """
        Imprime uma representa√ß√£o detalhada da lista mostrando as conex√µes.
        """
        print("\n" + "="*60)
        print("üìã ESTRUTURA DETALHADA DA LISTA DUPLAMENTE LIGADA")
        print("="*60)
        
        if self.esta_vazia():
            print("Lista vazia")
            return
        
        print(f"üìä Tamanho: {self.tamanho}")
        print(f"üü¢ Cabe√ßa: {self.cabeca.dados}")
        print(f"üî¥ Cauda: {self.cauda.dados}")
        print()
        
        no_atual = self.cabeca
        posicao = 0
        
        while no_atual is not None:
            anterior = no_atual.anterior.dados if no_atual.anterior else "None"
            proximo = no_atual.proximo.dados if no_atual.proximo else "None"
            
            print(f"Posi√ß√£o {posicao}: [{anterior}] ‚Üê [{no_atual.dados}] ‚Üí [{proximo}]")
            
            no_atual = no_atual.proximo
            posicao += 1
        
        print("="*60)


def demonstracao_basica():
    """
    Demonstra as funcionalidades b√°sicas da lista duplamente ligada.
    """
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë  Lista Duplamente Ligada - B√°sica     ‚ïë")
    print("‚ïë       Implementa√ß√£o Educacional       ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    print()
    
    # Cria√ß√£o da lista
    lista = ListaDuplamenteLigada()
    print(f"üìã Lista criada: {lista}")
    print()
    
    # Inser√ß√µes
    print("1Ô∏è‚É£  INSERINDO ELEMENTOS:")
    print("=" * 50)
    lista.inserir_inicio("primeiro")
    lista.inserir_fim("√∫ltimo")
    lista.inserir_inicio("novo_primeiro")
    lista.inserir_fim("novo_√∫ltimo")
    lista.inserir_posicao(2, "meio")
    
    print(f"\nüìã Lista atual: {lista}")
    lista.imprimir_detalhado()
    
    # Buscas
    print("\n2Ô∏è‚É£  BUSCANDO ELEMENTOS:")
    print("=" * 50)
    lista.buscar("meio")
    lista.buscar("inexistente")
    
    print(f"Elemento na posi√ß√£o 2: {lista.obter(2)}")
    print(f"Elemento na posi√ß√£o 0: {lista.obter(0)}")
    print(f"Elemento na posi√ß√£o {len(lista)-1}: {lista.obter(len(lista)-1)}")
    
    # Navega√ß√£o bidirecional
    print("\n3Ô∏è‚É£  NAVEGA√á√ÉO BIDIRECIONAL:")
    print("=" * 50)
    print("‚û°Ô∏è  Do in√≠cio ao fim:")
    for i, elemento in enumerate(lista):
        print(f"  Posi√ß√£o {i}: {elemento}")
    
    print("\n‚¨ÖÔ∏è  Do fim ao in√≠cio:")
    for i, elemento in enumerate(lista.iter_reverso()):
        print(f"  Posi√ß√£o {len(lista)-1-i}: {elemento}")
    
    # Convers√µes
    print("\n4Ô∏è‚É£  CONVERS√ïES PARA LISTA PYTHON:")
    print("=" * 50)
    print(f"Frente para tr√°s: {lista.para_lista_frente()}")
    print(f"Tr√°s para frente: {lista.para_lista_tras()}")
    
    # Remo√ß√µes
    print("\n5Ô∏è‚É£  REMOVENDO ELEMENTOS:")
    print("=" * 50)
    lista.remover_inicio()
    print(f"Lista ap√≥s remo√ß√£o: {lista}")
    
    lista.remover_fim()
    print(f"Lista ap√≥s remo√ß√£o: {lista}")
    
    lista.remover_valor("meio")
    print(f"Lista ap√≥s remo√ß√£o: {lista}")
    
    # Revers√£o
    print("\n6Ô∏è‚É£  REVERTENDO A LISTA:")
    print("=" * 50)
    print(f"Lista antes da revers√£o: {lista}")
    lista.reverter()
    print(f"Lista ap√≥s revers√£o: {lista}")
    
    # Estat√≠sticas finais
    print("\n7Ô∏è‚É£  ESTAT√çSTICAS FINAIS:")
    print("=" * 50)
    print(f"üìè Tamanho final: {len(lista)}")
    print(f"üì≠ Lista vazia? {lista.esta_vazia()}")
    
    lista.imprimir_detalhado()


def comparacao_com_lista_simples():
    """
    Compara opera√ß√µes entre lista simples e duplamente ligada.
    """
    print("\n" + "="*60)
    print("üìä COMPARA√á√ÉO: LISTA SIMPLES vs DUPLAMENTE LIGADA")
    print("="*60)
    
    # An√°lise de complexidade
    operacoes = [
        ("Inser√ß√£o no in√≠cio", "O(1)", "O(1)"),
        ("Inser√ß√£o no final", "O(n)*", "O(1)"),
        ("Remo√ß√£o do in√≠cio", "O(1)", "O(1)"),
        ("Remo√ß√£o do final", "O(n)", "O(1)"),
        ("Busca por valor", "O(n)", "O(n)"),
        ("Acesso por √≠ndice", "O(n)", "O(n/2)**"),
        ("Revers√£o", "O(n)", "O(n)"),
    ]
    
    print(f"{'Opera√ß√£o':<20} {'Lista Simples':<15} {'Lista Dupla':<15}")
    print("-" * 50)
    for op, simples, dupla in operacoes:
        print(f"{op:<20} {simples:<15} {dupla:<15}")
    
    print("\n* Com tail pointer: O(1)")
    print("** Busca otimizada (dire√ß√£o mais pr√≥xima)")
    
    print("\nüéØ QUANDO USAR LISTA DUPLAMENTE LIGADA:")
    vantagens = [
        "Remo√ß√µes frequentes no final da lista",
        "Navega√ß√£o bidirecional necess√°ria",
        "Implementa√ß√£o de estruturas como deques",
        "Opera√ß√µes de revers√£o frequentes",
        "Quando voc√™ tem refer√™ncia direta para os n√≥s"
    ]
    
    for vantagem in vantagens:
        print(f"  ‚úÖ {vantagem}")
    
    print("\n‚ö†Ô∏è  DESVANTAGENS:")
    desvantagens = [
        "Maior uso de mem√≥ria (ponteiro extra por n√≥)",
        "Maior complexidade de implementa√ß√£o",
        "Ligeiramente mais lenta para opera√ß√µes simples"
    ]
    
    for desvantagem in desvantagens:
        print(f"  ‚ùå {desvantagem}")


def exemplo_casos_uso():
    """
    Demonstra casos de uso pr√°ticos da lista duplamente ligada.
    """
    print("\n" + "="*60)
    print("üéØ CASOS DE USO PR√ÅTICOS")
    print("="*60)
    
    # Caso 1: Hist√≥rico de navega√ß√£o
    print("\n1Ô∏è‚É£  HIST√ìRICO DE NAVEGA√á√ÉO DE UM NAVEGADOR")
    print("-" * 50)
    
    historico = ListaDuplamenteLigada()
    
    paginas = ["google.com", "github.com", "stackoverflow.com", "python.org"]
    
    print("üì± Navegando pelas p√°ginas:")
    for pagina in paginas:
        historico.inserir_fim(pagina)
        print(f"  Visitou: {pagina}")
    
    print(f"\nüìã Hist√≥rico atual: {historico.para_lista_frente()}")
    
    print("\n‚¨ÖÔ∏è  Voltando p√°ginas:")
    while not historico.esta_vazia():
        pagina = historico.remover_fim()
        print(f"  Voltou para: {pagina if historico.cauda else 'p√°gina inicial'}")
        if historico.cauda:
            print(f"    P√°ginas restantes: {historico.para_lista_frente()}")
    
    # Caso 2: Editor de texto com undo/redo
    print("\n2Ô∏è‚É£  SISTEMA DE UNDO/REDO DE EDITOR")
    print("-" * 50)
    
    acoes = ListaDuplamenteLigada()
    
    operacoes = ["digitar 'Hello'", "digitar ' World'", "deletar 'World'", "digitar ' Python'"]
    
    print("‚úèÔ∏è  Realizando opera√ß√µes:")
    for operacao in operacoes:
        acoes.inserir_fim(operacao)
        print(f"  A√ß√£o: {operacao}")
    
    print(f"\nüìù Hist√≥rico de a√ß√µes: {acoes.para_lista_frente()}")
    
    print("\n‚Ü∂ Desfazendo opera√ß√µes:")
    for _ in range(2):
        if not acoes.esta_vazia():
            acao = acoes.remover_fim()
            print(f"  Undo: {acao}")
            print(f"    Estado atual: {acoes.para_lista_frente()}")
    
    # Caso 3: Player de m√∫sica
    print("\n3Ô∏è‚É£  PLAYER DE M√öSICA (PLAYLIST)")
    print("-" * 50)
    
    playlist = ListaDuplamenteLigada()
    
    musicas = ["Song A", "Song B", "Song C", "Song D"]
    
    for musica in musicas:
        playlist.inserir_fim(musica)
    
    print(f"üéµ Playlist: {playlist.para_lista_frente()}")
    
    print("\n‚èØÔ∏è  Navega√ß√£o na playlist:")
    print("  ‚ñ∂Ô∏è  Reprodu√ß√£o normal:")
    for musica in playlist:
        print(f"    üéµ Tocando: {musica}")
    
    print("\n  ‚óÄÔ∏è  Reprodu√ß√£o reversa:")
    for musica in playlist.iter_reverso():
        print(f"    üéµ Tocando: {musica}")


if __name__ == "__main__":
    demonstracao_basica()
    comparacao_com_lista_simples()
    exemplo_casos_uso()
    
    print("\n" + "="*60)
    print("üìö AN√ÅLISE DE COMPLEXIDADE RESUMIDA")
    print("="*60)
    print("‚ö° Inser√ß√£o/Remo√ß√£o nas extremidades: O(1)")
    print("üîç Busca por valor: O(n)")
    print("üìç Acesso por √≠ndice: O(n) - otimizado para O(n/2)")
    print("üîÑ Revers√£o: O(n)")
    print("üíæ Espa√ßo extra: O(n) - um ponteiro adicional por n√≥")
    
    print("\nüí° DICAS DE IMPLEMENTA√á√ÉO:")
    print("  ‚Ä¢ Sempre mantenha cabeca e cauda atualizadas")
    print("  ‚Ä¢ Verifique casos especiais (lista vazia, um elemento)")
    print("  ‚Ä¢ Use busca bidirecional para otimizar acesso por √≠ndice")
    print("  ‚Ä¢ Teste bem as opera√ß√µes de inser√ß√£o/remo√ß√£o no meio")
    print("  ‚Ä¢ Cuidado com vazamentos de mem√≥ria em linguagens sem GC")
